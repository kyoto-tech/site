---
import EventList from "../components/EventList.jsx";

const EVENTS_URL = "https://www.meetup.com/kyoto-tech-meetup/events/";

async function fetchMeetupEvents() {
	const html = await fetch(EVENTS_URL).then((r) => r.text());

	// Grab the JSON embedded in the __NEXT_DATA__ script tag
	const match = html.match(
		/<script id="__NEXT_DATA__" type="application\/json">([\s\S]*?)<\/script>/
	);

	if (!match?.[1]) return [];

	const data = JSON.parse(match[1]);
	const apolloState = data?.props?.pageProps?.__APOLLO_STATE__ as
		| Record<string, any>
		| undefined;
	if (!apolloState) return [];

	const now = new Date();
	const cutoff = new Date();
	cutoff.setDate(cutoff.getDate() + 60);

	const resolvePhotoUrl = (photoLike: any) => {
		const ref =
			(typeof photoLike === "string" && photoLike.startsWith("PhotoInfo:"))
				? photoLike
				: photoLike?.__ref ??
				  (photoLike?.id ? `PhotoInfo:${photoLike.id}` : null);

		if (!ref) return null;
		const photo = apolloState[ref];
		if (!photo) return null;

		return (
			photo.highResUrl ??
			photo.source ??
			(photo.baseUrl && photo.id ? `${photo.baseUrl}${photo.id}` : null)
		);
	};

	const resolveVenue = (venueLike: any) => {
		const ref =
			(typeof venueLike === "string" && venueLike.startsWith("Venue:"))
				? venueLike
				: venueLike?.__ref ??
				  (venueLike?.id ? `Venue:${venueLike.id}` : null);

		const venue = ref ? apolloState[ref] : venueLike;
		if (!venue) return null;

		return {
			name: venue.name,
			address: venue.address,
			city: venue.city,
			state: venue.state,
			country: venue.country
		};
	};

	const events = Object.entries(apolloState)
		.filter(([key, value]) => key.startsWith("Event:") && (value as any)?.dateTime)
		.map(([, rawValue]) => {
			const value = rawValue as any;
			return {
				title: value.title?.replace(" | Kyoto Tech Meetup", "") ?? value.title,
				link: value.eventUrl,
				start: value.dateTime,
				endTime: value.endTime ?? null,
				description: value.description ?? "",
				image: resolvePhotoUrl(value.featuredEventPhoto),
				goingCount: value.going?.totalCount ?? 0,
				interestedCount: value.socialProofInsights?.totalInterestedUsers ?? 0,
				venue: resolveVenue(value.venue)
			};
		})
		.filter((evt) => {
			const start = new Date(evt.start);
			return start >= now && start <= cutoff;
		})
		.sort((a, b) => new Date(a.start).valueOf() - new Date(b.start).valueOf());

	return events;
}

const events = await fetchMeetupEvents();

---

<section class="pt-6 pb-6">

  <EventList client:load events={events} />

</section>
